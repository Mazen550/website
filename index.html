<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Happy Valentine's Day</title>
<style>
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
    }
    canvas {
        display: block;
    }
</style>
</head>
<body>
<canvas id="starfield"></canvas>
<script>
const canvas = document.getElementById("starfield");
const context = canvas.getContext("2d");

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// ===== STARFIELD =====
let stars = [];
const starCount = Math.min(300, canvas.width/2); // fewer stars for mobile
const colorRange = [0, 60, 240];

function rand(min, max) { return Math.random() * (max - min) + min; }

for (let i=0; i<starCount; i++){
    stars.push({
        x: rand(0, canvas.width),
        y: rand(0, canvas.height),
        radius: rand(0.5, 1.5),
        hue: colorRange[Math.floor(rand(0, colorRange.length))],
        sat: rand(50,100),
        opacity: rand(0.2,1)
    });
}

// ===== HEART =====
let heartParticles = [];
let heartCount = Math.min(1500, canvas.width*2); // reduce for performance
let heartAngle = 0;
let heartVisible = false;

function heartShape(t, layer){
    const scale = 12;
    return {
        x: scale*16*Math.pow(Math.sin(t),3),
        y: -scale*(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)),
        z: layer
    };
}

function createHeart(){
    heartParticles = [];
    let layers = 20; // less layers for speed
    let particlesPerLayer = Math.floor(heartCount / layers);
    for (let layer=0; layer<layers; layer++){
        let zDepth = (layer/layers - 0.5) * 150;
        for (let i=0; i<particlesPerLayer; i++){
            let t = (i/particlesPerLayer) * Math.PI*2;
            let pos = heartShape(t, zDepth);
            let scaleRandom = Math.random();
            heartParticles.push({
                currentX: rand(-canvas.width, canvas.width),
                currentY: rand(-canvas.height, canvas.height),
                currentZ: rand(-500, 500),
                targetX: pos.x*scaleRandom,
                targetY: pos.y*scaleRandom,
                targetZ: pos.z + rand(-20,20)
            });
        }
    }
}
createHeart();

// ===== TEXT =====
const messages = [
    "everyday day I cannot believe how lucky I am",
    "amongst trillions and trillions of stars, over billions of years",
    "to be alive, and to get to spend this life with you",
    "is so incredibly, unfathomably unlikely",
    "and yet here I am to get the impossible chance to get to know you",
    "I love you so much Dalal, more than all the time and space in the universe can contain",
    "and I can't wait to spend all the time in the world to share that love with you!"
];

let startTime = performance.now();

function drawStars(){
    for (let star of stars){
        context.beginPath();
        context.arc(star.x, star.y, star.radius, 0, Math.PI*2);
        context.fillStyle = `hsla(${star.hue},${star.sat}%,88%,${star.opacity})`;
        context.fill();
        if (Math.random() > 0.995) star.opacity = rand(0.2,1);
    }
}

function drawHeart(){
    heartAngle += 0.008;
    const cos = Math.cos(heartAngle);
    const sin = Math.sin(heartAngle);

    let sorted = heartParticles.slice().sort((a,b)=>{
        let za = a.targetX*sin + a.targetZ*cos;
        let zb = b.targetX*sin + b.targetZ*cos;
        return za - zb;
    });

    for (let p of sorted){
        p.currentX += (p.targetX - p.currentX)*0.03;
        p.currentY += (p.targetY - p.currentY)*0.03;
        p.currentZ += (p.targetZ - p.currentZ)*0.03;

        let x = p.currentX*cos - p.currentZ*sin;
        let z = p.currentX*sin + p.currentZ*cos;
        let scale = 250/(250+z);

        let px = x*scale + canvas.width/2;
        let py = p.currentY*scale + canvas.height/2;
        let size = scale*2.5;
        let brightness = Math.max(0.3, Math.min(1, scale));
        context.fillStyle = `rgba(255,150,200,${brightness*0.8})`;
        context.fillRect(px, py, size, size);
    }
}

function drawText(time){
    let t = (time - startTime)/1000; // seconds
    context.font = `${Math.min(30,canvas.width/24)}px Comic Sans MS`;
    context.textAlign = "center";
    context.shadowColor = "rgba(255,100,200,1)";
    context.shadowBlur = 10;

    // Simple time-based fade logic
    const fadeDuration = 3; // seconds for fade in/out
    const displayDuration = 3; // seconds fully visible
    let yPos = canvas.height/2;

    messages.forEach((msg,i)=>{
        let msgStart = i*(fadeDuration*2 + displayDuration);
        let opacity = 0;
        if (t >= msgStart && t < msgStart + fadeDuration){
            opacity = (t - msgStart)/fadeDuration;
        } else if (t >= msgStart + fadeDuration && t < msgStart + fadeDuration + displayDuration){
            opacity = 1;
        } else if (t >= msgStart + fadeDuration + displayDuration && t < msgStart + fadeDuration*2 + displayDuration){
            opacity = 1 - (t - (msgStart + fadeDuration + displayDuration))/fadeDuration;
        }
        if (opacity>0){
            context.fillStyle = `rgba(255,150,200,${opacity})`;
            context.fillText(msg, canvas.width/2, i>=5 ? canvas.height*0.18 + (i-5)*60 : yPos);
        }
    });

    if (t > (messages.length-2)*(fadeDuration*2 + displayDuration)){
        heartVisible = true;
    }
}

function draw(time){
    context.fillStyle = "rgba(0,0,0,0.25)";
    context.fillRect(0,0,canvas.width,canvas.height);

    drawStars();
    drawText(time);
    if (heartVisible) drawHeart();

    requestAnimationFrame(draw);
}
requestAnimationFrame(draw);
</script>
</body>
</html>
